#!/bin/bash
# Test script for AI Router setup

set -e

echo "==================================="
echo "AI Router Test Suite"
echo "Five-Route Routing Pipeline"
echo "==================================="
echo ""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Counters
PASS=0
FAIL=0
WARN=0

# Base URL
BASE_URL="http://localhost"

# Test function
test_endpoint() {
    local name="$1"
    local url="$2"
    local method="${3:-GET}"
    local data="$4"
    
    echo -n "Testing $name... "
    
    if [ "$method" == "POST" ]; then
        response=$(curl -s -w "\n%{http_code}" -X POST "$url" \
            -H "Content-Type: application/json" \
            -d "$data" 2>/dev/null || echo "000")
    else
        response=$(curl -s -w "\n%{http_code}" "$url" 2>/dev/null || echo "000")
    fi
    
    http_code=$(echo "$response" | tail -n1)
    body=$(echo "$response" | sed '$d')
    
    if [ "$http_code" == "200" ] || [ "$http_code" == "201" ]; then
        echo -e "${GREEN}✓ PASS${NC} (HTTP $http_code)"
        PASS=$((PASS + 1))
        return 0
    else
        echo -e "${RED}✗ FAIL${NC} (HTTP $http_code)"
        echo "Response: $body"
        FAIL=$((FAIL + 1))
        return 1
    fi
}

# Check if services are running
echo "1. Checking if services are running..."
echo ""

if ! docker compose -f infra/docker-compose.yml --env-file .env --env-file .secrets ps | grep -q "Up"; then
    echo -e "${RED}Error: Services are not running. Start with 'make up'${NC}"
    exit 1
fi

echo -e "${GREEN}✓ Services are running${NC}"
echo ""

# Wait for services to be ready
echo "2. Waiting for services to be ready (this may take 2-3 minutes)..."
echo ""

max_wait=300
elapsed=0
while [ $elapsed -lt $max_wait ]; do
    if curl -s "$BASE_URL/health" > /dev/null 2>&1; then
        echo -e "${GREEN}✓ AI Router is ready${NC}"
        break
    fi
    echo -n "."
    sleep 5
    elapsed=$((elapsed + 5))
done

if [ $elapsed -ge $max_wait ]; then
    echo -e "${RED}Timeout waiting for services${NC}"
    exit 1
fi

echo ""

# Test health endpoints
echo "3. Testing health endpoints..."
echo ""

test_endpoint "AI Router Health" "$BASE_URL/health"
test_endpoint "Router Model Health" "$BASE_URL/router/health"
test_endpoint "Primary Model Health" "$BASE_URL/primary/health"

echo ""

# Test model listing
echo "4. Testing model endpoints..."
echo ""

test_endpoint "List All Models" "$BASE_URL/v1/models"
test_endpoint "Router Models" "$BASE_URL/router/v1/models"
test_endpoint "Primary Models" "$BASE_URL/primary/v1/models"

echo ""

# Test chat completions (simple query -> router)
echo "5. Testing simple query routing..."
echo ""

simple_data='{
  "messages": [{"role": "user", "content": "Hello"}],
  "max_tokens": 50,
  "temperature": 0.7
}'

echo "Sending simple query: 'Hello'"
response=$(curl -s -X POST "$BASE_URL/v1/chat/completions" \
    -H "Content-Type: application/json" \
    -d "$simple_data")

# Check for either content or reasoning_content (for reasoning models)
content=$(echo "$response" | jq -r '.choices[0].message.content // .choices[0].message.reasoning_content // empty')
model=$(echo "$response" | jq -r '.model // empty')

if [ -n "$content" ] && [ "$content" != "null" ]; then
    echo -e "${GREEN}✓ Simple query successful${NC}"
    PASS=$((PASS + 1))
    echo "Response: $(echo "$content" | head -c 100)..."

    # Verify routing to primary model (SIMPLE now routes to Nano 30B)
    if [[ "$model" == *"Nemotron-3-Nano-30B"* ]]; then
        echo -e "${GREEN}✓ Correctly routed to primary model (Nano 30B)${NC}"
        PASS=$((PASS + 1))
    else
        echo -e "${YELLOW}⚠ Routed to: $model (expected Nano 30B)${NC}"
        WARN=$((WARN + 1))
    fi
else
    echo -e "${RED}✗ Simple query failed${NC}"
    FAIL=$((FAIL + 1))
    echo "Response: $response"
fi

echo ""

# Test chat completions (moderate query -> primary)
echo "6. Testing moderate query routing..."
echo ""

complex_data='{
  "messages": [{"role": "user", "content": "Explain the concept of quantum entanglement in detail"}],
  "max_tokens": 200,
  "temperature": 0.7
}'

echo "Sending moderate query: 'Explain quantum entanglement...'"
response=$(curl -s -X POST "$BASE_URL/v1/chat/completions" \
    -H "Content-Type: application/json" \
    -d "$complex_data")

# Check for either content or reasoning_content (for reasoning models)
content=$(echo "$response" | jq -r '.choices[0].message.content // .choices[0].message.reasoning_content // empty')
model=$(echo "$response" | jq -r '.model // empty')

if [ -n "$content" ] && [ "$content" != "null" ]; then
    echo -e "${GREEN}✓ Moderate query successful${NC}"
    PASS=$((PASS + 1))
    echo "Response: $(echo "$content" | head -c 100)..."

    # Verify routing to Nano 30B
    if [[ "$model" == *"Nemotron-3-Nano-30B"* ]]; then
        echo -e "${GREEN}✓ Correctly routed to primary model (Nano 30B)${NC}"
        PASS=$((PASS + 1))
    else
        echo -e "${YELLOW}⚠ Routed to: $model (expected Nano 30B)${NC}"
        WARN=$((WARN + 1))
    fi
else
    echo -e "${RED}✗ Moderate query failed${NC}"
    FAIL=$((FAIL + 1))
    echo "Response: $response"
fi

echo ""

# Test highly complex query routing (xAI)
echo "7. Testing highly complex query routing (xAI)..."
echo ""

highly_complex_data='{
  "messages": [{"role": "user", "content": "Design a novel quantum-resistant cryptographic algorithm that can handle post-quantum threats"}],
  "max_tokens": 100,
  "temperature": 0.7
}'

echo "Sending highly complex query: 'Design quantum-resistant crypto...'"
response=$(curl -s -X POST "$BASE_URL/v1/chat/completions" \
    -H "Content-Type: application/json" \
    -d "$highly_complex_data")

# Check for either content or reasoning_content (for reasoning models)
content=$(echo "$response" | jq -r '.choices[0].message.content // .choices[0].message.reasoning_content // empty')
model=$(echo "$response" | jq -r '.model // empty')

if [ -n "$content" ] && [ "$content" != "null" ]; then
    echo -e "${GREEN}✓ Highly complex query successful${NC}"
    PASS=$((PASS + 1))
    echo "Response: $(echo "$content" | head -c 100)..."

    # Verify routing to xAI
    if [[ "$model" == *"grok"* ]]; then
        echo -e "${GREEN}✓ Correctly routed to xAI model (Grok)${NC}"
        PASS=$((PASS + 1))
    else
        echo -e "${YELLOW}⚠ Routed to: $model (expected Grok)${NC}"
        WARN=$((WARN + 1))
    fi
else
    echo -e "${RED}✗ Highly complex query failed${NC}"
    FAIL=$((FAIL + 1))
    echo "Response: $response"
fi

echo ""

# Test enrichment query routing
echo "8. Testing enrichment query routing..."
echo ""

enrich_data='{
  "messages": [{"role": "user", "content": "What is the current weather in Tokyo right now?"}],
  "max_tokens": 500,
  "temperature": 0.7
}'

echo "Sending enrichment query: 'What is the current weather in Tokyo right now?'"
response=$(curl -s -X POST "$BASE_URL/v1/chat/completions" \
    -H "Content-Type: application/json" \
    -d "$enrich_data")

# Check for either content or reasoning_content (for reasoning models)
content=$(echo "$response" | jq -r '.choices[0].message.content // .choices[0].message.reasoning_content // empty')
model=$(echo "$response" | jq -r '.model // empty')

if [ -n "$content" ] && [ "$content" != "null" ]; then
    echo -e "${GREEN}✓ Enrichment query successful${NC}"
    PASS=$((PASS + 1))
    echo "Response: $(echo "$content" | head -c 100)..."

    # Enrichment routes to primary model after context injection
    if [[ "$model" == *"Nemotron-3-Nano-30B"* ]]; then
        echo -e "${GREEN}✓ Correctly routed through enrichment pipeline to primary model${NC}"
        PASS=$((PASS + 1))
    else
        echo -e "${YELLOW}⚠ Routed to: $model (expected Nano 30B via enrichment)${NC}"
        WARN=$((WARN + 1))
    fi
else
    echo -e "${RED}✗ Enrichment query failed${NC}"
    FAIL=$((FAIL + 1))
    echo "Response: $response"
fi

echo ""

# Test meta pipeline routing
echo "9. Testing meta pipeline routing..."
echo ""

# Meta-prompts are single-message requests >300 chars with embedded conversation markers.
# Build a payload that triggers the meta detection heuristics in determine_route().
meta_data='{
  "messages": [{"role": "user", "content": "### Task:\nGenerate three follow-up questions the user might ask based on this conversation.\n\n### Guidelines:\n- Questions should be concise\n- Questions should be diverse\n\n<chat_history>\nUSER: What is the capital of France?\nASSISTANT: The capital of France is Paris.\n</chat_history>\n\nProvide exactly three follow-up questions, one per line."}],
  "max_tokens": 100,
  "temperature": 0.7
}'

echo "Sending meta-prompt (embedded chat history with task markers)..."
response=$(curl -s -X POST "$BASE_URL/v1/chat/completions" \
    -H "Content-Type: application/json" \
    -d "$meta_data")

content=$(echo "$response" | jq -r '.choices[0].message.content // .choices[0].message.reasoning_content // empty')
model=$(echo "$response" | jq -r '.model // empty')

if [ -n "$content" ] && [ "$content" != "null" ]; then
    echo -e "${GREEN}✓ Meta pipeline query successful${NC}"
    PASS=$((PASS + 1))
    echo "Response: $(echo "$content" | head -c 100)..."

    # Meta routes to primary model (Nano 30B)
    if [[ "$model" == *"Nemotron-3-Nano-30B"* ]]; then
        echo -e "${GREEN}✓ Correctly routed through meta pipeline to primary model${NC}"
        PASS=$((PASS + 1))
    else
        echo -e "${YELLOW}⚠ Routed to: $model (expected Nano 30B via meta pipeline)${NC}"
        WARN=$((WARN + 1))
    fi
else
    echo -e "${RED}✗ Meta pipeline query failed${NC}"
    FAIL=$((FAIL + 1))
    echo "Response: $response"
fi

echo ""

# Test lengthy MODERATE queries (validates --max-model-len on router isn't too tight)
echo "10. Testing lengthy moderate query (code review)..."
echo ""

# ~1500 chars of code — should classify as MODERATE and route to primary.
# Also acts as a canary: if the router's --max-model-len is too small,
# the classification request will fail with HTTP 400.
lengthy_code_data='{
  "messages": [{"role": "user", "content": "Review this Python code and suggest improvements:\n\nimport os\nimport sys\nimport json\nimport logging\nfrom pathlib import Path\nfrom datetime import datetime, timedelta\nfrom collections import defaultdict\n\nlogger = logging.getLogger(__name__)\n\nclass SessionAnalyzer:\n    def __init__(self, log_dir, max_age_days=7):\n        self.log_dir = Path(log_dir)\n        self.max_age_days = max_age_days\n        self.stats = defaultdict(int)\n        self.errors = []\n        self.latencies = defaultdict(list)\n\n    def scan(self):\n        cutoff = datetime.now() - timedelta(days=self.max_age_days)\n        for path in sorted(self.log_dir.glob(\"*.json\")):\n            try:\n                with open(path) as f:\n                    session = json.load(f)\n                ts = datetime.fromisoformat(session.get(\"timestamp\", \"\"))\n                if ts < cutoff:\n                    continue\n                route = session.get(\"route\", \"unknown\")\n                self.stats[route] += 1\n                if session.get(\"error\"):\n                    self.errors.append({\"file\": path.name, \"error\": session[\"error\"], \"route\": route})\n                for step in session.get(\"steps\", []):\n                    if \"duration_ms\" in step:\n                        self.latencies[step.get(\"provider\", \"unknown\")].append(step[\"duration_ms\"])\n            except (json.JSONDecodeError, KeyError, ValueError) as e:\n                logger.warning(f\"Skipping {path.name}: {e}\")\n\n    def summarize(self):\n        total = sum(self.stats.values())\n        summary = {\"total_sessions\": total, \"by_route\": dict(self.stats), \"error_count\": len(self.errors)}\n        for provider, vals in self.latencies.items():\n            summary[f\"avg_latency_{provider}_ms\"] = round(sum(vals) / len(vals), 1)\n        return summary\n\nif __name__ == \"__main__\":\n    analyzer = SessionAnalyzer(sys.argv[1] if len(sys.argv) > 1 else \"logs/sessions\")\n    analyzer.scan()\n    print(json.dumps(analyzer.summarize(), indent=2))"}],
  "max_tokens": 300,
  "temperature": 0.7
}'

echo "Sending lengthy code review (~1500 chars of Python code)..."
response=$(curl -s -X POST "$BASE_URL/v1/chat/completions" \
    -H "Content-Type: application/json" \
    -d "$lengthy_code_data")

content=$(echo "$response" | jq -r '.choices[0].message.content // .choices[0].message.reasoning_content // empty')
model=$(echo "$response" | jq -r '.model // empty')
error_msg=$(echo "$response" | jq -r '.error.message // empty')

if [ -n "$error_msg" ] && [ "$error_msg" != "null" ]; then
    # Classification failed — likely --max-model-len too small for this input
    echo -e "${RED}✗ Lengthy code review FAILED (classification error)${NC}"
    echo "Error: $error_msg"
    echo "This may indicate --max-model-len on the router is too small."
    FAIL=$((FAIL + 1))
elif [ -n "$content" ] && [ "$content" != "null" ]; then
    echo -e "${GREEN}✓ Lengthy code review successful${NC}"
    PASS=$((PASS + 1))
    echo "Response: $(echo "$content" | head -c 100)..."

    if [[ "$model" == *"Nemotron-3-Nano-30B"* ]]; then
        echo -e "${GREEN}✓ Correctly routed to primary model (not escalated to xAI)${NC}"
        PASS=$((PASS + 1))
    elif [[ "$model" == *"grok"* ]]; then
        echo -e "${YELLOW}⚠ Routed to xAI — misclassified as COMPLEX (expected MODERATE)${NC}"
        WARN=$((WARN + 1))
    else
        echo -e "${YELLOW}⚠ Routed to: $model (expected Nano 30B)${NC}"
        WARN=$((WARN + 1))
    fi
else
    echo -e "${RED}✗ Lengthy code review failed${NC}"
    FAIL=$((FAIL + 1))
    echo "Response: $response"
fi

echo ""

# Test lengthy SIMPLE query — a verbose but fundamentally basic question
echo "11. Testing lengthy simple query (verbose but basic)..."
echo ""

lengthy_simple_data='{
  "messages": [{"role": "user", "content": "I have been learning programming for about six months now and I started with JavaScript because a friend recommended it, then moved on to Python which I find much easier to read and understand. I have been working through various tutorials and online courses and I feel like I have a decent grasp of the basics like variables, loops, conditionals, functions, and basic data structures. I have also started learning about object-oriented programming and I understand classes and inheritance at a surface level. My question is pretty straightforward: what is a dictionary in Python and how is it different from a list? I know they are both used to store collections of data but I get confused about when to use which one. Can you explain the key differences in simple terms?"}],
  "max_tokens": 300,
  "temperature": 0.7
}'

echo "Sending lengthy but basic query (~700 chars, asks a simple question)..."
response=$(curl -s -X POST "$BASE_URL/v1/chat/completions" \
    -H "Content-Type: application/json" \
    -d "$lengthy_simple_data")

content=$(echo "$response" | jq -r '.choices[0].message.content // .choices[0].message.reasoning_content // empty')
model=$(echo "$response" | jq -r '.model // empty')
error_msg=$(echo "$response" | jq -r '.error.message // empty')

if [ -n "$error_msg" ] && [ "$error_msg" != "null" ]; then
    echo -e "${RED}✗ Lengthy simple query FAILED (classification error)${NC}"
    echo "Error: $error_msg"
    echo "This may indicate --max-model-len on the router is too small."
    FAIL=$((FAIL + 1))
elif [ -n "$content" ] && [ "$content" != "null" ]; then
    echo -e "${GREEN}✓ Lengthy simple query successful${NC}"
    PASS=$((PASS + 1))
    echo "Response: $(echo "$content" | head -c 100)..."

    if [[ "$model" == *"Nemotron-3-Nano-30B"* ]]; then
        echo -e "${GREEN}✓ Correctly routed to primary model (not escalated to xAI)${NC}"
        PASS=$((PASS + 1))
    elif [[ "$model" == *"grok"* ]]; then
        echo -e "${YELLOW}⚠ Routed to xAI — misclassified as COMPLEX (expected SIMPLE/MODERATE)${NC}"
        WARN=$((WARN + 1))
    else
        echo -e "${YELLOW}⚠ Routed to: $model (expected Nano 30B)${NC}"
        WARN=$((WARN + 1))
    fi
else
    echo -e "${RED}✗ Lengthy simple query failed${NC}"
    FAIL=$((FAIL + 1))
    echo "Response: $response"
fi

echo ""

# Test direct router access
echo "12. Testing direct model access..."
echo ""

router_data='{
  "model": "cyankiwi/Nemotron-Orchestrator-8B-AWQ-4bit",
  "messages": [{"role": "user", "content": "Hi there"}],
  "max_tokens": 30
}'

echo "Testing direct router model access..."
response=$(curl -s -X POST "$BASE_URL/router/v1/chat/completions" \
    -H "Content-Type: application/json" \
    -d "$router_data")

# Check for either content or reasoning_content (for reasoning models)
content=$(echo "$response" | jq -r '.choices[0].message.content // .choices[0].message.reasoning_content // empty' 2>/dev/null)
if [ -n "$content" ] && [ "$content" != "null" ]; then
    echo -e "${GREEN}✓ Direct router access successful${NC}"
    PASS=$((PASS + 1))
else
    echo -e "${RED}✗ Direct router access failed${NC}"
    FAIL=$((FAIL + 1))
    echo "Response: $response"
fi

echo ""

primary_data='{
  "model": "unsloth/NVIDIA-Nemotron-3-Nano-30B-A3B-NVFP4",
  "messages": [{"role": "user", "content": "Quick test"}],
  "max_tokens": 30
}'

echo "Testing direct primary model access..."
response=$(curl -s -X POST "$BASE_URL/primary/v1/chat/completions" \
    -H "Content-Type: application/json" \
    -d "$primary_data")

# Check for either content or reasoning_content (for reasoning models)
content=$(echo "$response" | jq -r '.choices[0].message.content // .choices[0].message.reasoning_content // empty' 2>/dev/null)
if [ -n "$content" ] && [ "$content" != "null" ]; then
    echo -e "${GREEN}✓ Direct primary access successful${NC}"
    PASS=$((PASS + 1))
else
    echo -e "${RED}✗ Direct primary access failed${NC}"
    FAIL=$((FAIL + 1))
    echo "Response: $response"
fi

echo ""

# Test additional endpoints
echo "13. Testing additional endpoints..."
echo ""

test_endpoint "Root Endpoint" "$BASE_URL/"
test_endpoint "Stats Endpoint" "$BASE_URL/stats"
test_endpoint "Explicit Route API" "$BASE_URL/api/route" "POST" '{"route": "primary", "data": {"messages": [{"role": "user", "content": "Hi"}], "max_tokens": 10}}'

echo ""

# Test Traefik dashboard
echo "14. Testing Traefik dashboard..."
echo ""

if curl -s "http://localhost:8080/api/overview" | jq . > /dev/null 2>&1; then
    echo -e "${GREEN}✓ Traefik dashboard accessible${NC}"
    PASS=$((PASS + 1))
    echo "Visit: http://localhost:8080"
else
    echo -e "${YELLOW}⚠ Traefik dashboard not accessible${NC}"
    WARN=$((WARN + 1))
fi

echo ""

# Summary
echo "==================================="
echo "Test Summary"
echo "==================================="
echo ""
echo -e "  ${GREEN}Passed:  $PASS${NC}"
echo -e "  ${RED}Failed:  $FAIL${NC}"
echo -e "  ${YELLOW}Warnings: $WARN${NC}"
echo ""

if [ "$FAIL" -gt 0 ]; then
    echo -e "${RED}Some tests failed!${NC}"
else
    echo -e "${GREEN}All tests passed!${NC}"
fi

echo ""
echo "Routing categories tested:"
echo "  • SIMPLE   → Nano 30B (primary model)"
echo "  • MODERATE → Nano 30B (primary model)"
echo "  • COMPLEX  → xAI Grok (external API)"
echo "  • ENRICH   → xAI context → Nano 30B (enrichment pipeline)"
echo "  • META     → Nano 30B (meta pipeline, skips classification)"
echo ""
echo "Next steps:"
echo "  • View logs: make logs"
echo "  • Run benchmarks: make benchmark"
echo "  • Traefik dashboard: http://localhost:8080"
echo ""